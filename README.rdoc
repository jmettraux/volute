
= volute

It could be a 'set event bus', 'on_set callback system' or a 'business logic relocator'.

It can be used to implement toy state machines, or dumb rule systems.


== include Volute

When the Volute mixin is included in a class, its attr_accessor call is modified so that the resulting attributer set method, upon setting the value of the attribute triggers a callback defined outside of the class.

  require 'rubygems'
  require 'volute' # gem install volute

  class Light
    include Volute

    attr_accessor :colour
    attr_accessor :changed_at
  end

  volute :colour do
    object.changed_at = Time.now
  end

  l = Light.new
  p l # => #<Light:0x10014c480>

  l.colour = :blue
  p l # => #<Light:0x10014c480 @changed_at=Fri Oct 08 20:01:52 +0900 2010, @colour=:blue>

There is a catch in this example, the volute will trigger for any class that inccludes Volute and which sees a change to its :colour attribute.

Those two classes would see their :colour hooked :

  class Light
    include Volute

    attr_accessor :colour
    attr_accessor :changed_at
  end

  class Flower
    include Volute

    attr_accessor :colour
  end

To make sure that only instance of Light will be concerned, one could write :

  volute Light do
    volute :colour do
      object.changed_at = Time.now
    end
  end

Inside of a volute, these are the available 'variables' :

* object - the instance whose attribute has been set
* attribute - the attribute name whose value has been set
* previous_value - the previous value for the attribute
* value - the new value

thus :

  volute Light do
    volute :colour do
      puts "#{object.class}.#{attribute} : #{previous_value.inspect} --> #{value.inspect}"
    end
  end

  l = Light.new
  l.colour = :blue
  l.colour = :red

would output :

  Light.colour : nil --> :blue
  Light.colour : :blue --> :red


== filters / guards

A volute combines a list of arguments with a block of ruby code

  volute do
    puts 'some attribute was set'
  end

  volute Light do
    puts 'some attribute of an instance of class Light was set'
  end

  volute Light, Flower do
    puts 'some attribute of an instance of class Light or Flower was set'
  end

  volute :count do
    puts 'the attribute :count of some instance got set'
  end

  volute :count, :number do
    puts 'the attribute :count or :number of some instance got set'
  end

  volute Light, :count do
    puts 'some attribute of an instance of class Light was set'
    puts 'OR'
    puts 'the attribute :count of some instance got set'
  end

As soon as 1 argument matches, the Ruby block of the volute is executed. In other words, arg0 OR arg1 OR ... OR argN

If you need for an AND, read on to "nesting volutes".

  volute 0 => 100 do
    puts "some attribute went from 0 to 100"
  end

  volute :any => 100 do
    puts "some attribute was just set to 100"
  end

  volute 0 => :any do
    puts "some attribute was at 0 and just got changed"
  end


== volute :not

A volute may have :not has a first argument

  volute :not, Invoice do
    puts "some instance that is not an invoice..."
  end

  volute :not, :any => :delivered do
    puts "a transition to something different than :delivered..."
  end

  volute :not, Invoice, :paid do
    puts "not an Invoice and not a variation of the :paid attribute..."
  end

Not Bob or Charlie, Nor Bob and neither Charlie.


== nesting volutes

Whereas enumerating arguments for a single volute played like an OR, to achieve AND, one can nest volutes.

  volute Invoice do
    volute :paid do
      puts "the :paid attribute of an Invoice just changed"
    end
  end

  volute Grant do
    volute :paid do
      puts "the :paid attribute of a Grant just changed"
    end
  end


== 'over'

TODO


== volute management

TODO


== examples

http://github.com/jmettraux/volute/tree/master/examples/


== author

John Mettraux - http://github.com/jmettraux/


== feedback

* IRC freenode #ruote
* jmettraux@gmail.com


== license

MIT, see LICENSE.txt

